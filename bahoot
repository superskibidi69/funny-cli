#!/bin/bash
set -e

# OS detection
detect_os() {
  case "$(uname -s)" in
    Linux*)   OS=Linux ;;
    Darwin*)  OS=Mac ;;
    CYGWIN*|MINGW*|MSYS*) OS=Windows ;;
    *)        OS=Unknown ;;
  esac
}

# Windows fallback
windows_fallback() {
  echo -e "\033[0;31mBahoot CLI requires Bash.\033[0m"
  echo "You appear to be running in Windows CMD or PowerShell."
  echo "Please use Git Bash, WSL, or a Bash-compatible terminal."
  echo "Download Git Bash: https://git-scm.com/download/win"
}

# üé® Terminal colors
RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# üåÄ Animated spinner loader
loader() {
  local i=0
  local spin='‚£∑‚£Ø‚£ü‚°ø‚¢ø‚£ª‚£Ω‚£æ'
  echo -n "Loading "
  while :; do
    printf "\b${spin:i++%${#spin}:1}"
    sleep 0.1
  done
}
# üöÄ ASCII rocket launch
rocket() {
  cols=$(tput cols)
  rocket="üöÄ"
  gas="üí®"
  explosion="üí•"
  rocket_len=2
  max_pos=$((cols-rocket_len-1))
  for ((i=0; i<=max_pos; i++)); do
    clear
    line=""
    # Draw gas trail behind rocket
    for ((j=0; j<i; j++)); do line+="$gas"; done
    # Draw rocket
    line+="$rocket"
    # Draw spaces after rocket (to fill line)
    for ((j=0; j<cols-i-rocket_len; j++)); do line+=" "; done
    # Draw explosion at end
    if ((i == max_pos)); then
      line+="$explosion"
    fi
    echo -e "${YELLOW}${line}${NC}"
    speed=$(echo "scale=3; 0.18 - ($i/$max_pos)*0.13" | bc)
    sleep $speed
  done
  echo -e "${GREEN}Rocket launch complete!${NC}"
}

# üß† Diagnostic scanner with CPU/Mem info
doctor() {
  echo -e "${GREEN}üîç Running diagnostics...${NC}"
  sleep 0.5
  echo "‚úÖ Bash version: $(bash --version | head -n 1)"
  echo "‚úÖ Terminal: $TERM"
  echo "‚úÖ User: $USER"
  echo "‚úÖ Host: $(hostname)"
  UPTIME=$(uptime -p 2>/dev/null || uptime)
  echo "‚úÖ Uptime: $UPTIME"
  
  # CPU info
  if command -v lscpu >/dev/null 2>&1; then
    echo "‚úÖ CPU: $(lscpu | grep 'Model name' | cut -d':' -f2 | xargs)"
  elif command -v sysctl >/dev/null 2>&1; then
    echo "‚úÖ CPU: $(sysctl -n machdep.cpu.brand_string)"
  fi
  
  # Memory info
  if command -v free >/dev/null 2>&1; then
    echo "‚úÖ Memory: $(free -h | grep Mem | awk '{print $3 "/" $2}') used"
  elif command -v vm_stat >/dev/null 2>&1; then
    memory=$(vm_stat | grep "Pages active" | awk '{print $3}' | tr -d '.')
    echo "‚úÖ Memory: ~$((memory / 256))MB active"
  fi
}

# üí• Fake meltdown with randomized errors
prank() {
  (loader) &
  loader_pid=$!
  sleep 2
  kill $loader_pid 2>/dev/null
  echo -e "\b \n"
  
  errors=(
    "KERNEL_SECURITY_CHECK_FAILURE"
    "CRITICAL_PROCESS_DIED" 
    "SYSTEM_THREAD_EXCEPTION_NOT_HANDLED"
    "IRQL_NOT_LESS_OR_EQUAL"
    "PAGE_FAULT_IN_NONPAGED_AREA"
    "DRIVER_IRQL_NOT_LESS_OR_EQUAL"
    "KMODE_EXCEPTION_NOT_HANDLED"
  )
  
  for i in {1..5}; do
    echo -e "${RED}üí• SYSTEM FAILURE DETECTED${NC}"
    sleep 0.2
    echo -e "${YELLOW} Dumping memory...${NC}"
    sleep 0.3
    echo -e "${RED} $(shuf -e "${errors[@]}" -n 1)${NC}"
    sleep 0.3
    clear
  done
  echo -e "${RED} Memory dumped.${NC}"
  sleep 1
  echo -e "${GREEN}Just kidding üòé${NC}"
}

# üß® Chaos mode with screen flashes - FIXED DIVISION BY ZERO
chaos() {
  echo -e "${CYAN}üß® Entering chaos mode...${NC}"
  sleep 0.5
  
  # Define errors array to avoid division by zero
  errors=(
    "KERNEL_SECURITY_CHECK_FAILURE"
    "CRITICAL_PROCESS_DIED" 
    "SYSTEM_THREAD_EXCEPTION_NOT_HANDLED"
    "IRQL_NOT_LESS_OR_EQUAL"
    "PAGE_FAULT_IN_NONPAGED_AREA"
    "DRIVER_IRQL_NOT_LESS_OR_EQUAL"
    "KMODE_EXCEPTION_NOT_HANDLED"
    "SANITY_NOT_FOUND"
    "BAHOOT_OVERFLOW"
    "TERMINAL_TOO_COOL"
  )
  errors_count=${#errors[@]}
  
  for i in {1..30}; do
    color=$((31 + (i % 6)))
    echo -e "\033[1;${color}mERROR $i: ${errors[$((RANDOM % errors_count))]}${NC}"
    
    # Random screen flash
    if ((RANDOM % 5 == 0)); then
      tput bel
      clear
      sleep 0.1
    fi
    
    sleep 0.07
  done
  
  for i in {1..10}; do
    echo -e "\033[1;33mCHAOS LEVEL: $((RANDOM % 100))%${NC}"
    sleep 0.05
  done
  echo -e "${CYAN}üí´ Chaos complete.${NC}"
}

# üß™ Matrix mode with pre-generated charset
matrix() {
  echo -e "${GREEN}üß™ Entering matrix mode...${NC}"
  cols=$(tput cols)
  rows=$(tput lines)
  
  # Pre-generate character set
  chars=()
  for c in {a..z} {A..Z} {0..9}; do
    chars+=("$c")
  done
  chars_len=${#chars[@]}
  
  trap "tput cnorm; clear; exit" SIGINT SIGTERM
  tput civis
  clear
  
  # Each stream has a position and length
  local -a pos
  local -a len
  for ((i=0; i<cols; i++)); do
    pos[i]=$((RANDOM % rows))
    len[i]=$((3 + RANDOM % (rows/2)))
  done
  
  for ((frame=0; frame<200; frame++)); do
    for ((i=0; i<cols; i++)); do
      # Print fading trail
      for ((j=0; j<len[i]; j++)); do
        y=$((pos[i] - j))
        if ((y > 0 && y <= rows)); then
          char_idx=$((RANDOM % chars_len))
          if ((j == 0)); then
            printf "\033[%d;%dH\033[1;97m%s\033[0m" "$y" "$((i+1))" "${chars[char_idx]}"
          elif ((j < len[i]/2)); then
            printf "\033[%d;%dH\033[1;32m%s\033[0m" "$y" "$((i+1))" "${chars[char_idx]}"
          else
            printf "\033[%d;%dH\033[0;32m%s\033[0m" "$y" "$((i+1))" "${chars[char_idx]}"
          fi
        fi
      done
      # Move stream down
      pos[i]=$((pos[i]+1))
      if ((pos[i] - len[i] > rows)); then
        pos[i]=1
        len[i]=$((3 + RANDOM % (rows/2)))
      fi
    done
    sleep 0.05
  done
  tput cnorm
  echo -e "${GREEN}\nüß† Matrix exited.${NC}"
}

# Banner with pulse effect after typing
banner() {
  local lines=(
" ______  _______ _     _  _____   _____  _______"
" |_____] |_____| |_____| |     | |     |    |   "
" |_____] |     | |     | |_____| |_____|    |   "
  )
  clear
  for line in "${lines[@]}"; do
    # print each character with a short delay for a typewriter effect
    for ((i=0; i<${#line}; i++)); do
      echo -ne "${CYAN}${line:$i:1}${NC}"
      sleep 0.01
    done
    echo ""  # new line after each banner line
    sleep 0.15
  done
  
  # Pulse effect
  for i in {1..3}; do
    for color in "${CYAN}" "${BLUE}" "${MAGENTA}" "${CYAN}"; do
      printf "\033[3A"  # Move up 3 lines
      for line in "${lines[@]}"; do
        echo -ne "${color}${line}${NC}"
        echo
      done
      sleep 0.2
    done
  done
}

# üîÑ Self-update with checksum verification
update() {
  echo -e "${CYAN}üîÑ Updating Bahoot CLI...${NC}"
  
  # Create backup and calculate checksum
  local backup_file="$0.bak"
  cp "$0" "$backup_file"
  local old_checksum=$(md5sum "$0" | cut -d' ' -f1 2>/dev/null || md5 -q "$0" 2>/dev/null)
  
  # Download update
  if curl -fsSL https://raw.githubusercontent.com/superskibidi69/funny-cli/main/bahoot -o "$0.tmp"; then
    local new_checksum=$(md5sum "$0.tmp" | cut -d' ' -f1 2>/dev/null || md5 -q "$0.tmp" 2>/dev/null)
    
    # Verify checksum is different (actual update)
    if [ "$old_checksum" != "$new_checksum" ]; then
      chmod +x "$0.tmp"
      mv "$0.tmp" "$0"
      echo -e "${GREEN}‚úÖ Update complete!${NC}"
    else
      rm "$0.tmp"
      echo -e "${YELLOW}‚ÑπÔ∏è  Already up to date.${NC}"
    fi
    rm -f "$backup_file"
  else
    echo -e "${RED}‚ùå Update failed. Restoring backup.${NC}"
    mv "$backup_file" "$0"
  fi
}

# üí£ uninstall with countdown
uninstall() {
  echo -e "${RED}üí£ Uninstall sequence initiated...${NC}"
  for i in {5..1}; do
    echo -e "${RED}$i...${NC}"
    sleep 1
  done
  echo "Deleting Bahoot CLI from: $0"
  rm -- "$0"
  echo -e "${RED}üí• BOOM!${NC}"
}

# üé≠ Troll mode with random delays
troll() {
  (loader) &
  loader_pid=$!
  sleep 2
  kill $loader_pid 2>/dev/null
  echo -e "\b \n"
  
  messages=("Installing virus..." "Formatting disk..." "Sending your IP to Bahoot HQ..." "Just kidding üòé")
  for msg in "${messages[@]}"; do
    echo -e "${RED}$msg${NC}"
    # Random delay between 0.1 and 0.6 seconds
    sleep $(awk "BEGIN {print 0.1 + 0.5 * $RANDOM / 32767}")
  done
}

# üéâ Party mode with ASCII fireworks
party() {
  echo -e "${YELLOW}üéâ Welcome to Bahoot Party Mode!${NC}"
  
  fireworks=(
"          .     .\n         / \\   / \\\n    .---'     '     '---.\n   /                     \\\n  (      B A H O O T      )\n   \\                     /\n    ''--.         .--''\n         '-------'"
"    *       .\n      *   *\n   .    *    .\n      *   *\n    *       ."
"   \\ | /\n  - BAHOOT -\n   / | \\"
"   .-^-.\n  /     \\\n ( B A H )\n  \\     /\n   '-.-'"
  )
  
  for i in {1..5}; do
    clear
    color=$((31 + (RANDOM % 6)))
    echo -e "\033[1;${color}m${fireworks[$RANDOM % ${#fireworks[@]}]}${NC}"
    echo -e "\033[1;${color}müéä üéà üéâ Bahoot rocks! üéâ üéà üéä${NC}"
    sleep 0.3
  done
  echo -e "${GREEN}üéµ Party's over, back to work!${NC}"
}

# üèì Pong game (first to 10 wins)
pong() {
  # Hide cursor and disable input echoing
  tput civis
  stty -echo
  
  # Game variables
  local cols=$(tput cols)
  local rows=$(tput lines)
  local score_left=0
  local score_right=0
  local paddle_height=6
  local left_paddle_y=$((rows/2 - paddle_height/2))
  local right_paddle_y=$((rows/2 - paddle_height/2))
  local ball_x=$((cols/2))
  local ball_y=$((rows/2))
  local ball_dx=1
  local ball_dy=1
  local winner=""
  local paddle_char="‚ñà"
  local ball_char="‚óè"
  local prev_ball_x=$ball_x
  local prev_ball_y=$ball_y
  local quit_game=0
  local ball_speed=0.05  # Slightly slower ball speed
  
  # Colors
  local left_color="\033[1;36m"   # Cyan
  local right_color="\033[1;35m"  # Magenta
  local ball_color="\033[1;33m"   # Yellow
  local score_color="\033[1;32m"  # Green
  
  # Trap to restore terminal settings on exit
  trap "tput cnorm; stty echo; clear; exit" SIGINT SIGTERM
  
  # Draw the initial game state
  clear
  
  # Draw borders and initial score
  printf "\033[0;0H"
  printf "${score_color}Player: %-2d   CPU: %-2d${NC}\n" "$score_left" "$score_right"
  printf "‚ïê%.0s" $(seq 1 $cols)
  for ((y=3; y<rows-1; y++)); do
    printf "\033[%d;0H" "$y"
    printf " "
    printf "\033[%d;%dH" "$y" "$cols"
    printf " "
  done
  printf "\033[%d;0H" "$((rows-1))"
  printf "‚ïê%.0s" $(seq 1 $cols)
  printf "\033[%d;0H" "$rows"
  printf "Use ‚Üë/‚Üì to move, Q to quit"
  
  # Draw initial paddles
  for ((i=0; i<paddle_height; i++)); do
    printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$((left_paddle_y + i))"
    printf "\033[%d;%dH${right_color}${paddle_char}${NC}" "$((right_paddle_y + i))" "$((cols-1))"
  done
  
  # Draw initial ball
  printf "\033[%d;%dH${ball_color}${ball_char}${NC}" "$ball_y" "$ball_x"
  
  # Game loop
  while [[ $score_left -lt 10 && $score_right -lt 10 && $quit_game -eq 0 ]]; do
    # Store previous ball position
    prev_ball_x=$ball_x
    prev_ball_y=$ball_y
    
    # Move ball
    ball_x=$((ball_x + ball_dx))
    ball_y=$((ball_y + ball_dy))
    
    # Ball collision with top/bottom - fix sticking at edges
    if [[ $ball_y -le 2 ]]; then
      ball_y=3
      ball_dy=1
    elif [[ $ball_y -ge $((rows-1)) ]]; then
      ball_y=$((rows-2))
      ball_dy=-1
    fi
    
    # Ball collision with left paddle - fix paddle "splitting"
    if [[ $ball_x -eq 1 && $ball_y -ge $left_paddle_y && $ball_y -lt $((left_paddle_y + paddle_height)) ]]; then
      ball_dx=1
      # Adjust angle based on where the ball hit the paddle
      local hit_pos=$((ball_y - left_paddle_y))
      if [[ $hit_pos -eq 0 || $hit_pos -eq 1 ]]; then
        ball_dy=-1
      elif [[ $hit_pos -eq $((paddle_height-1)) || $hit_pos -eq $((paddle_height-2)) ]]; then
        ball_dy=1
      else
        ball_dy=0  # Straight shot for middle hits
      fi
      # Ensure ball doesn't get stuck in paddle
      ball_x=2
    fi
    
    # Ball collision with right paddle (CPU) - fix paddle "splitting"
    if [[ $ball_x -eq $((cols-2)) && $ball_y -ge $right_paddle_y && $ball_y -lt $((right_paddle_y + paddle_height)) ]]; then
      ball_dx=-1
      # Adjust angle based on where the ball hit the paddle
      local hit_pos=$((ball_y - right_paddle_y))
      if [[ $hit_pos -eq 0 || $hit_pos -eq 1 ]]; then
        ball_dy=-1
      elif [[ $hit_pos -eq $((paddle_height-1)) || $hit_pos -eq $((paddle_height-2)) ]]; then
        ball_dy=1
      else
        ball_dy=0  # Straight shot for middle hits
      fi
      # Ensure ball doesn't get stuck in paddle
      ball_x=$((cols-3))
    fi
    
    # Score points
    if [[ $ball_x -le 0 ]]; then
      score_right=$((score_right + 1))
      # Update score display immediately
      printf "\033[0;15H${score_color}%-2d${NC}" "$score_right"
      ball_x=$((cols/2))
      ball_y=$((rows/2))
      ball_dx=1
      ball_dy=$((RANDOM % 3 - 1))  # Random initial angle
      # Clear old ball
      printf "\033[%d;%dH " "$prev_ball_y" "$prev_ball_x"
      # Draw new ball
      printf "\033[%d;%dH${ball_color}${ball_char}${NC}" "$ball_y" "$ball_x"
      # Redraw paddles to fix any visual issues
      for ((i=0; i<paddle_height; i++)); do
        printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$((left_paddle_y + i))"
        printf "\033[%d;%dH${right_color}${paddle_char}${NC}" "$((right_paddle_y + i))" "$((cols-1))"
      done
      sleep 0.5
      continue
    elif [[ $ball_x -ge $((cols-1)) ]]; then
      score_left=$((score_left + 1))
      # Update score display immediately
      printf "\033[0;8H${score_color}%-2d${NC}" "$score_left"
      ball_x=$((cols/2))
      ball_y=$((rows/2))
      ball_dx=-1
      ball_dy=$((RANDOM % 3 - 1))  # Random initial angle
      # Clear old ball
      printf "\033[%d;%dH " "$prev_ball_y" "$prev_ball_x"
      # Draw new ball
      printf "\033[%d;%dH${ball_color}${ball_char}${NC}" "$ball_y" "$ball_x"
      # Redraw paddles to fix any visual issues
      for ((i=0; i<paddle_height; i++)); do
        printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$((left_paddle_y + i))"
        printf "\033[%d;%dH${right_color}${paddle_char}${NC}" "$((right_paddle_y + i))" "$((cols-1))"
      done
      sleep 0.5
      continue
    fi
    
    # Improved CPU AI - better prediction and movement
    if [[ $ball_dx -gt 0 ]]; then  # Only move when ball is coming towards CPU
      # Predict where the ball will be
      local predicted_y=$ball_y
      local steps_to_reach=$(( (cols - 2 - ball_x) / ball_dx ))
      
      # Calculate bounce if needed
      if [[ $ball_dy -ne 0 ]]; then
        for ((i=0; i<steps_to_reach; i++)); do
          predicted_y=$((predicted_y + ball_dy))
          if [[ $predicted_y -le 2 ]]; then
            predicted_y=3
            ball_dy=1
          elif [[ $predicted_y -ge $((rows-1)) ]]; then
            predicted_y=$((rows-2))
            ball_dy=-1
          fi
        done
      fi
      
      # Move CPU paddle toward predicted position with some imperfection
      local target_y=$((predicted_y - paddle_height/2))
      
      # Add some randomness to make CPU beatable
      if (( RANDOM % 5 == 0 )); then  # 20% chance of error
        target_y=$((target_y + (RANDOM % 5 - 2)))
      fi
      
      # Keep target within bounds
      if [[ $target_y -lt 2 ]]; then
        target_y=2
      elif [[ $target_y -gt $((rows - paddle_height - 1)) ]]; then
        target_y=$((rows - paddle_height - 1))
      fi
      
      # Move CPU paddle
      if [[ $target_y -lt $right_paddle_y ]]; then
        # Move up
        if [[ $right_paddle_y -gt 2 ]]; then
          # Clear bottom of paddle
          printf "\033[%d;%dH " "$((right_paddle_y + paddle_height - 1))" "$((cols-1))"
          right_paddle_y=$((right_paddle_y - 1))
          # Draw top of paddle
          printf "\033[%d;%dH${right_color}${paddle_char}${NC}" "$right_paddle_y" "$((cols-1))"
        fi
      elif [[ $target_y -gt $right_paddle_y ]]; then
        # Move down
        if [[ $right_paddle_y -lt $((rows - paddle_height - 1)) ]]; then
          # Clear top of paddle
          printf "\033[%d;%dH " "$right_paddle_y" "$((cols-1))"
          right_paddle_y=$((right_paddle_y + 1))
          # Draw bottom of paddle
          printf "\033[%d;%dH${right_color}${paddle_char}${NC}" "$((right_paddle_y + paddle_height - 1))" "$((cols-1))"
        fi
      fi
    fi
    
    # Keep paddles in bounds
    if [[ $left_paddle_y -lt 2 ]]; then
      left_paddle_y=2
    elif [[ $left_paddle_y -gt $((rows - paddle_height - 1)) ]]; then
      left_paddle_y=$((rows - paddle_height - 1))
    fi
    
    if [[ $right_paddle_y -lt 2 ]]; then
      right_paddle_y=2
    elif [[ $right_paddle_y -gt $((rows - paddle_height - 1)) ]]; then
      right_paddle_y=$((rows - paddle_height - 1))
    fi
    
    # Read input with minimal delay for responsive controls
    local key=""
    while read -t 0.001 -n 1 -s key; do
      case "$key" in
        $'\033') 
          # Handle arrow keys
          read -t 0.001 -n 2 -s rest
          case "$rest" in
            "[A") # Up arrow
              if [[ $left_paddle_y -gt 2 ]]; then
                # Clear bottom of paddle
                printf "\033[%d;0H " "$((left_paddle_y + paddle_height - 1))"
                left_paddle_y=$((left_paddle_y - 1))
                # Draw top of paddle
                printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$left_paddle_y"
              fi
              ;;
            "[B") # Down arrow
              if [[ $left_paddle_y -lt $((rows - paddle_height - 1)) ]]; then
                # Clear top of paddle
                printf "\033[%d;0H " "$left_paddle_y"
                left_paddle_y=$((left_paddle_y + 1))
                # Draw bottom of paddle
                printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$((left_paddle_y + paddle_height - 1))"
              fi
              ;;
          esac
          ;;
        w|W) 
          # Move left paddle up
          if [[ $left_paddle_y -gt 2 ]]; then
            # Clear bottom of paddle
            printf "\033[%d;0H " "$((left_paddle_y + paddle_height - 1))"
            left_paddle_y=$((left_paddle_y - 1))
            # Draw top of paddle
            printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$left_paddle_y"
          fi
          ;;
        s|S) 
          # Move left paddle down
          if [[ $left_paddle_y -lt $((rows - paddle_height - 1)) ]]; then
            # Clear top of paddle
            printf "\033[%d;0H " "$left_paddle_y"
            left_paddle_y=$((left_paddle_y + 1))
            # Draw bottom of paddle
            printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$((left_paddle_y + paddle_height - 1))"
          fi
          ;;
        q|Q) 
          quit_game=1
          break 2  # Break out of both loops
          ;;
      esac
    done
    
    # Only redraw ball if it moved
    if [[ $prev_ball_x -ne $ball_x || $prev_ball_y -ne $ball_y ]]; then
      # Clear old ball position
      printf "\033[%d;%dH " "$prev_ball_y" "$prev_ball_x"
      # Draw new ball position
      printf "\033[%d;%dH${ball_color}${ball_char}${NC}" "$ball_y" "$ball_x"
    fi
    
    # Small delay to make game playable (slightly slower ball)
    sleep $ball_speed
  done
  
  # Clear the game screen first
  clear
  
  # Display final results BEFORE restoring terminal settings
  if [[ $quit_game -eq 1 ]]; then
    echo -e "${score_color}Game quit${NC}"
    echo -e "Final score: ${score_color}Player: $score_left   CPU: $score_right${NC}"
  elif [[ $score_left -eq 10 ]]; then
    echo -e "${score_color}üèÜ Player wins! üèÜ${NC}"
    echo -e "Final score: ${score_color}Player: $score_left   CPU: $score_right${NC}"
  elif [[ $score_right -eq 10 ]]; then
    echo -e "${score_color}üèÜ CPU wins! üèÜ${NC}"
    echo -e "Final score: ${score_color}Player: $score_left   CPU: $score_right${NC}"
  fi
  
  # Restore terminal settings
  tput cnorm
  stty echo
  
  # Wait for a key press before returning
  echo
  read -n 1 -s -p "Press any key to continue..."
}

# ü¶† Fake virus scan with progress bar
scan() {
  echo -e "${RED}ü¶† Scanning system for viruses...${NC}"
  
  # Progress bar animation
  for i in {1..20}; do
    percent=$((i * 5))
    bar=""
    for ((j=0; j<i; j++)); do bar+="‚ñà"; done
    for ((j=i; j<20; j++)); do bar+="‚ñë"; done
    echo -ne "\r[${bar}] ${percent}%"
    sleep 0.2
  done
  echo -e "\n"
  
  sleep 1
  echo "Found: 3 threats"
  sleep 1
  echo "Threat 1: Bahoot overload"
  echo "Threat 2: Excessive swag"
  echo "Threat 3: Terminal too cool"
  echo -e "${GREEN}‚úÖ All threats neutralized.${NC}"
}

# üñ•Ô∏è Boot sequence with BIOS-style status
boot() {
  echo -e "${CYAN}üñ•Ô∏è Booting Bahoot OS...${NC}"
  sleep 0.5
  
  boot_messages=(
    "Initializing kernel.............[ ${GREEN}OK${NC} ]"
    "Loading modules.................[ ${GREEN}OK${NC} ]"
    "Mounting /bahoot................[ ${GREEN}OK${NC} ]"
    "Checking system integrity.......[ ${GREEN}OK${NC} ]"
    "Starting services...............[ ${GREEN}OK${NC} ]"
  )
  
  for msg in "${boot_messages[@]}"; do
    echo -e "$msg"
    sleep 0.5
  done
  
  echo "Welcome to Bahoot OS ü§ñ"
}

# üíª Fake hacking with random IPs
hack() {
  echo -e "${GREEN}üíª Hacking in progress...${NC}"
  for i in {1..20}; do
    ip="$((RANDOM % 255)).$((RANDOM % 255)).$((RANDOM % 255)).$((RANDOM % 255))"
    echo "Accessing $ip... success"
    sleep 0.1
  done
  echo -e "${RED}üî• Firewall breached. Just kidding.${NC}"
}

# ‚ö° Glitch effect with color inversion
glitch() {
  chars="‚ñà‚ñì‚ñí‚ñë@#$%^&*()[]{}<>~ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
  cols=$(tput cols)
  for i in {1..15}; do
    clear
    for j in {1..8}; do
      len=$((10 + RANDOM % cols))
      str=""
      for ((k=0; k<len; k++)); do
        str+="${chars:RANDOM%${#chars}:1}"
      done
      color=$((31 + RANDOM % 7))
      
      # Random color inversion
      if ((RANDOM % 4 == 0)); then
        echo -e "\033[7;${color}m${str}${NC}"
      else
        echo -e "\033[1;${color}m${str}${NC}"
      fi
    done
    sleep 0.07
  done
  echo -e "${GREEN}System stabilized.${NC}"
}

# ü¶ë Squid mode with water ripple effect
squid() {
  echo -e "${CYAN}ü¶ë Squid mode activated!${NC}"
  squid_frames=(
    "    ___\n   /   \\\n  | o o |\n   \\_-_/\n    |||\n   /|||\\\n  ( ||| )\n   \\|||/\n    vvv"
    "    ___\n   /   \\\n  | ^ ^ |\n   \\_-_/\n    |||\n   /|||\\\n  ( ||| )\n   \\|||/\n    ^^^  "
    "    ___\n   /   \\\n  | - - |\n   \\_u_/\n    |||\n   /|||\\\n  ( ||| )\n   \\|||/\n    ~~~"
    "    ___\n   /   \\\n  | o o |\n   \\_-_/\n    |||\n   \\|||/\n  ( ||| )\n   /|||\\\n    ^^^  "
  )
  
  ripple_frames=("~~~" "‚âà‚âà‚âà" "ÔΩûÔΩûÔΩû" "‚àø‚àø‚àø")
  
  for cycle in {1..3}; do
    for frame in "${squid_frames[@]}"; do
      clear
      echo -e "${CYAN}$frame${NC}"
      echo -e "${BLUE}${ripple_frames[$RANDOM % ${#ripple_frames[@]}]}${NC}"
      echo -e "\n${GREEN}~ Swimming through the depths ~${NC}"
      sleep 0.4
    done
  done
  echo -e "${CYAN}ü¶ë Squid out!${NC}"
}

# ü¶Ü Duck spam with random pitch
duck() {
  echo -e "${YELLOW}Quack! Quack! Quack!${NC}"
  duck_frames=(
    "       __\n      (o >\n   \\_\\_\\)#_)\n~~~~~~~~~~~~~~~~~~~~~~~~"
    "       __\n      (o<\n   \\_\\_\\)#_)\n~~~~~~~~~~~~~~~~~~~~~~~~"
    "       __\n      (o >\n   \\_\\_\\)#_)  *splash*\n~~~~~~~~~~~~~~~~~~~~~~~~"
    "       __\n      (^ >\n   \\_\\_\\)#_)\n~~~~~~~~~~~~~~~~~~~~~~~~"
  )
  
  quacks=("QUACK!" "Quack!" "QUACK!!!" "quack..." "Quack?")
  
  positions=(5 10 15 20 25 30 20 15 10 5)
  
  for cycle in {1..2}; do
    for pos in "${positions[@]}"; do
      clear
      echo
      for ((i=0; i<pos; i++)); do echo -n " "; done
      echo -e "${YELLOW}${duck_frames[$((cycle % 4))]}${NC}"
      echo -e "\n${GREEN}${quacks[$RANDOM % ${#quacks[@]}]} Swimming around the pond!${NC}"
      sleep 0.3
    done
  done
  echo -e "${GREEN}All ducks have swum away.${NC}"
}

# ü¶Ä Crab rave with beat sync
crab() {
  echo -e "${CYAN}ü¶Ä Crab rave started!${NC}"
  crab_frames=(
    "   \\o/  \\o/\n    |    |\n  _/ \\__/ \\_\n {.  \\_/  .}\n  \\._    _./\n     |  |\n    /    \\"
    "   \\o|  |o/\n    |    |\n  _/ \\__/ \\_\n {.  \\_/  .}\n  \\._    _./\n     |  |\n    /    \\"
    "   /o\\  /o\\\n    |    |\n  _/ \\__/ \\_\n {.  \\_/  .}\n  \\._    _./\n     |  |\n    /    \\"
    "   |o/  \\o|\n    |    |\n  _/ \\__/ \\_\n {.  \\_/  .}\n  \\._    _./\n     |  |\n    /    \\"
  )
  
  positions=(2 8 15 22 28 35 28 22 15 8 2)
  
  for cycle in {1..4}; do
    for pos in "${positions[@]}"; do
      clear
      echo
      for ((i=0; i<pos; i++)); do echo -n " "; done
      echo -e "${RED}${crab_frames[$((cycle % 4))]}${NC}"
      echo -e "\n${YELLOW}üéµ Crab rave! Moving sideways! üéµ${NC}"
      
      # Sync with beat - flash every 4 cycles
      if ((cycle % 4 == 0)); then
        sleep 0.2
        clear
        echo
        for ((i=0; i<pos; i++)); do echo -n " "; done
        echo -e "${YELLOW}${crab_frames[$((cycle % 4))]}${NC}"
        echo -e "\n${YELLOW}üéµ CRAB RAVE! üéµ${NC}"
      fi
      
      sleep 0.3
    done
  done
  echo -e "${GREEN}Crab rave ended.${NC}"
}

# üê∏ Frog rain from random positions
frog() {
  echo -e "${GREEN}üê∏ Frog rain incoming...${NC}"
  cols=$(tput cols)
  for i in {1..20}; do
    x=$((RANDOM % cols + 1))
    printf "\033[2;%dHüê∏" "$x"
    sleep 0.07
  done
  echo -e "\033[10;0H${CYAN}Frogs gone!${NC}"
}

# üçÄ Fortune with timestamp and color cycle
fortune() {
  quotes=("You will write bug-free code today." "Bahoot believes in you." "Your terminal is your canvas." "Don't forget to hydrate.")
  fortune_text="${quotes[$RANDOM % ${#quotes[@]}]}"
  
  # Color cycle
  colors=("$GREEN" "$CYAN" "$YELLOW" "$BLUE" "$MAGENTA")
  color="${colors[$RANDOM % ${#colors[@]}]}"
  
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  echo -e "${color}üçÄ Fortune [${timestamp}]:${NC} $fortune_text"
}

# üîä Echo with flair and uppercase
echo_cmd() {
  echo -e "${CYAN}üîä YOU SAID:${NC} ${*^^}"
}

# üßº Clear screen with fade effect
clear_cmd() {
  rows=$(tput lines)
  cols=$(tput cols)
  
  # Fill screen with spaces to create fade effect
  for ((i=0; i<rows; i++)); do
    line=""
    for ((j=0; j<cols; j++)); do
      line+=" "
    done
    echo "$line"
    sleep 0.02
  done
  
  clear
  echo -e "${GREEN}üßº Screen cleared.${NC}"
}

# üìú Credits with scrolling effect
credits() {
  credits_text=(
    "BAHOOT CLI CREDITS"
    "=================="
    ""
    "Created by: superfood"
    "Inspired by: chaos and shell magic"
    ""
    "Special thanks to:"
    "‚Ä¢ The terminal enthusiasts"
    "‚Ä¢ The open source community"
    "‚Ä¢ Everyone who loves fun CLI tools"
    ""
    "Remember: Your terminal is your canvas!"
    ""
    "THE END"
  )
  
  rows=$(tput lines)
  clear
  
  for ((i=0; i<${#credits_text[@]}+rows; i++)); do
    clear
    for ((j=0; j<rows; j++)); do
      line_idx=$((i - j))
      if (( line_idx >= 0 && line_idx < ${#credits_text[@]} )); then
        # Center text
        text="${credits_text[line_idx]}"
        cols=$(tput cols)
        padding=$(( (cols - ${#text}) / 2 ))
        printf "%${padding}s" ""
        echo -e "${CYAN}${text}${NC}"
      else
        echo
      fi
    done
    sleep 0.2
  done
}

# üßº Help menu with aligned columns
help_menu() {
  echo -e "${CYAN}Bahoot CLI ü§ñ ‚Äî Available commands:${NC}"
  printf "%-16s %s\n" "  ball" "Bouncing ball with color trail"
  printf "%-16s %s\n" "  banner" "Animated Bahoot ASCII logo"
  printf "%-16s %s\n" "  boot" "Simulate Bahoot OS boot sequence"
  printf "%-16s %s\n" "  chaos" "Print colorful chaos errors"
  printf "%-16s %s\n" "  crab" "Crab rave animation"
  printf "%-16s %s\n" "  credits" "Show Bahoot CLI credits"
  printf "%-16s %s\n" "  clear" "Clear the screen"
  printf "%-16s %s\n" "  deploy" "Launch ASCII rocket"
  printf "%-16s %s\n" "  doctor" "Show system diagnostics"
  printf "%-16s %s\n" "  duck" "Spam the terminal with ducks"
  printf "%-16s %s\n" "  echo [text]" "Repeat your input with flair"
  printf "%-16s %s\n" "  fortune" "Get a random fortune/quote"
  printf "%-16s %s\n" "  frog" "Frog rain animation"
  printf "%-16s %s\n" "  glitch" "Terminal glitch effect"
  printf "%-16s %s\n" "  hack" "Fake hacking animation"
  printf "%-16s %s\n" "  help" "Show this help menu"
  printf "%-16s %s\n" "  matrix" "Matrix movie rain effect"
  printf "%-16s %s\n" "  party" "Celebrate with confetti"
  printf "%-16s %s\n" "  prank" "Fake system meltdown"
  printf "%-16s %s\n" "  scan" "Fake virus scan"
  printf "%-16s %s\n" "  uninstall" "Dramatically delete Bahoot CLI"
  printf "%-16s %s\n" "  squid" "Squid mode animation"
  printf "%-16s %s\n" "  pong" "Play Pong (first to 10 wins)"
  printf "%-16s %s\n" "  troll" "Print fake errors and warnings"
  printf "%-16s %s\n" "  update" "Update Bahoot CLI from GitHub"
}

# Ball function - kept exactly as requested
ball() {
  tput civis  # hide cursor
  stty -echo  # disable input echoing
  
  local cols=$(tput cols)
  local rows=$(tput lines)
  local x=$((cols / 2))
  local y=$((rows / 2))
  local dx=1
  local dy=1
  local ball="‚óè"
  local trail_char="¬∑"
  local colors=(31 32 33 36 35 34)  # ANSI color codes: red, green, yellow, cyan, magenta, blue
  local color_index=0
  local trail_length=12  # Increased length for better visual effect
  
  # Arrays to store trail positions and colors
  local -a trail_x=()
  local -a trail_y=()
  local -a trail_c=()
  local -a trail_age=()  # Track age of each trail segment
  
  # Clear screen initially
  clear

  trap "tput cnorm; stty echo; clear; exit" SIGINT SIGTERM

  while true; do
    # Store current position for trail (with age 0)
    trail_x=("$x" "${trail_x[@]:0:$trail_length}")
    trail_y=("$y" "${trail_y[@]:0:$trail_length}")
    trail_c=("$color_index" "${trail_c[@]:0:$trail_length}")
    trail_age=(0 "${trail_age[@]:0:$trail_length}")  # Newest trail has age 0

    # Clear previous ball position
    printf "\033[%d;%dH " "$y" "$x"

    # Draw trail with fading effect based on age
    for ((t=0; t<${#trail_x[@]}; t++)); do
      if [[ -n "${trail_x[t]}" && -n "${trail_y[t]}" ]]; then
        # Increase age of this trail segment
        trail_age[t]=$((trail_age[t] + 1))
        
        # Remove trail segments that are too old
        if [[ ${trail_age[t]} -gt $((trail_length / 2)) ]]; then
          printf "\033[%d;%dH " "${trail_y[t]}" "${trail_x[t]}"
          # Mark for removal by setting to empty
          trail_x[t]=""
          trail_y[t]=""
        else
          # Calculate fade intensity based on age
          local fade_intensity=$((trail_age[t] * 2))
          if [[ $fade_intensity -gt 5 ]]; then
            fade_intensity=5  # Cap the fade intensity
          fi
          
          # Draw with appropriate fade
          printf "\033[%d;%dH\033[2;%dm%s\033[0m" "${trail_y[t]}" "${trail_x[t]}" "${colors[trail_c[t]]}" "$trail_char"
        fi
      fi
    done

    # Move ball
    ((x += dx))
    ((y += dy))

    # Bounce off edges with proper boundary checking
    if ((x <= 1)); then
      x=2
      dx=$(( -dx ))
      color_index=$(( (color_index + 1) % ${#colors[@]} ))
    elif ((x >= cols)); then
      x=$((cols - 1))
      dx=$(( -dx ))
      color_index=$(( (color_index + 1) % ${#colors[@]} ))
    fi

    if ((y <= 1)); then
      y=2
      dy=$(( -dy ))
      color_index=$(( (color_index + 1) % ${#colors[@]} ))
    elif ((y >= rows)); then
      y=$((rows - 1))
      dy=$(( -dy ))
      color_index=$(( (color_index + 1) % ${#colors[@]} ))
    fi

    # Draw ball with current color
    printf "\033[%d;%dH\033[1;%dm%s\033[0m" "$y" "$x" "${colors[$color_index]}" "$ball"

    # Refresh display
    printf "\033[0;0H"  # Move cursor to top-left to minimize flickering

    sleep 0.0635363
  done
}

case "$1" in
  prank) prank ;;
  deploy) rocket ;;
  chaos) chaos ;;
  matrix) matrix ;;
  doctor) doctor ;;
  banner) banner ;;
  update) update ;;
  uninstall) uninstall ;;
  troll) troll ;;
  party) party ;;
  scan) scan ;;
  boot) boot ;;
  hack) hack ;;
  glitch) glitch ;;
  ball) ball ;;
  squid) squid ;;
  duck) duck ;;
  crab) crab ;;
  frog) frog ;;
  fortune) fortune ;;
  pong) pong ;;
  echo) shift; echo_cmd "$@" ;;
  clear) clear_cmd ;;
  credits) credits ;;
  help|"") help_menu ;;   # no banner here
  *) help_menu ;;
esac