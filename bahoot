#!/bin/bash
set -e

# OS detection
detect_os() {
  case "$(uname -s)" in
    Linux*)   OS=Linux ;;
    Darwin*)  OS=Mac ;;
    CYGWIN*|MINGW*|MSYS*) OS=Windows ;;
    *)        OS=Unknown ;;
  esac
}

# Windows fallback
windows_fallback() {
  echo -e "\033[0;31mBahoot CLI requires Bash.\033[0m"
  echo "You appear to be running in Windows CMD or PowerShell."
  echo "Please use Git Bash, WSL, or a Bash-compatible terminal."
  echo "Download Git Bash: https://git-scm.com/download/win"
}

# 🎨 Terminal colors
RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

loader() {
  local i=0
  local spin='⣷⣯⣟⡿⢿⣻⣽⣾'
  echo -n "Loading "
  while :; do
    printf "\b${spin:i++%${#spin}:1}"
    sleep 0.1
  done
}
# 🚂 Enhanced SL command - Steam locomotive with multiple train types
sl() {
  local train_type="steam"
  local reverse=0
  local fly=0
  local accident=0
  local little=0
  local colors=1
  local smoke_trail=1
  
  # Parse command line options
  while [[ $# -gt 0 ]]; do
    case $1 in
      -F) fly=1; shift ;;
      -l) little=1; shift ;;
      -a) accident=1; shift ;;
      -r) reverse=1; shift ;;
      -c) colors=0; shift ;;
      -s) smoke_trail=0; shift ;;
      -freight) train_type="freight"; shift ;;
      -bullet) train_type="bullet"; shift ;;
      -metro) train_type="metro"; shift ;;
      -tram) train_type="tram"; shift ;;
      -rocket) train_type="rocket"; shift ;;
      *) shift ;;  # Ignore unknown arguments
    esac
  done
  
  # Hide cursor and disable input echoing
  tput civis
  stty -echo
  
  local cols=$(tput cols)
  local rows=$(tput lines)
  local ground_level=$((rows - 3))
  [[ $fly -eq 1 ]] && ground_level=$((rows / 2))
  
  # Set colors if enabled
  local train_color=""
  local smoke_color=""
  local spark_color=""
  local ground_color=""
  local rocket_flame_color=""
  if [[ $colors -eq 1 ]]; then
    train_color="\033[1;31m"
    smoke_color="\033[1;37m" 
    spark_color="\033[1;33m"
    ground_color="\033[0;32m"
    rocket_flame_color="\033[1;31m"
  fi
  local NC="\033[0m"
  
  # Define train frames for different types
  case $train_type in
    "steam")
      if [[ $little -eq 1 ]]; then
        train_frames=(
          "      (  ) (@@) ( )  (@)  ()    @@    O     @     O     @      O"
          "    (   )  @@  ( )   @@    ()  @@    O     @     O     @      O"
          "  (    ) (@@) ( )   (@@)   () @@    O     @     O     @      O"
        )
      else
        train_frames=(
          "                      (@@@@)     (@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)"
          "                    (   )  )@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)"
          "                 (    ))@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)"
          "              _|--O--O  )@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)"
          "            /         | )@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)"
          "           |           )@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
          "          (           )@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
          "           |          |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
          "           __________/|_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
          "          |     |      |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
          "          | BHT |      |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
          "          |_____|______|@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
          "         (oo)     (oo)  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
        )
      fi
      ;;
    "freight")
      train_frames=(
        "     _____          ______        ______        ______"
        "    |     |        |      |      |      |      |      |"
        "    | BOX |        | TANK |      | COAL |      | FLAT |"
        "    |_____|________|______|______|______|______|______|"
        "       (o)    (o)     (o)   (o)    (o)   (o)    (o)   (o)"
      )
      ;;
    "bullet")
      train_frames=(
        "    ___====-_  _-====___________"
        "  _--^^^#####//      \\\\#####^^^--_"
        " -^##########// (    ) \\\\##########^-"
        "_############//  \\__/   \\\\############_"
        "############//    )(    \\\\############"
        "###########//      ||     \\\\###########"
        "##########//       ||      \\\\##########"
        "^#########//        ||       \\\\#########^"
        " ^########//         ||        \\\\########^"
        "  ^######//          ||         \\\\######^"
        "    ^###//           ||          \\\\###^"
        "      ^//            ||           \\\\^"
      )
      ;;
    "metro")
      train_frames=(
        "  ___________________"
        " |[] [] [] [] [] [] []|"
        " |                   |"
        " |    METRO LINE 1   |"
        " |___________________|"
        "   (o)           (o)"
      )
      ;;
    "tram")
      train_frames=(
        "    _______________"
        "   |###############|"
        "   |  O   TRAM  O  |"
        "   |_______________|"
        "     (o)       (o)"
      )
      ;;
    "rocket")
      train_frames=(
        "           /\\"
        "          /  \\"
        "         | ** |"
        "        /|    |\\"
        "       / | ** | \\"
        "      |  |    |  |"
        "      |  | ** |  |"
        "     /   |    |   \\"
        "    /    | ** |    \\"
        "   |     |    |     |"
        "   |_____| ** |_____|"
        "         |    |"
        "         | ** |"
        "         |____|"
        "        /      \\"
        "       /        \\"
        "      /__________\\"
      )
      ;;
  esac
  
  # Calculate train width (longest line)
  local train_width=0
  for line in "${train_frames[@]}"; do
    if [[ ${#line} -gt $train_width ]]; then
      train_width=${#line}
    fi
  done
  
  # Set up cleanup trap
  trap "tput cnorm; stty echo; clear; exit" SIGINT SIGTERM
  
  # Initialize position variables
  local start_pos
  local end_pos
  local step
  if [[ $reverse -eq 1 ]]; then
    start_pos=$((cols + train_width))
    end_pos=-$train_width
    step=-2
  else
    start_pos=-$train_width
    end_pos=$((cols + train_width))
    step=2
  fi
  
  # Arrays for special effects
  local -a smoke_x=()
  local -a smoke_y=()
  local -a smoke_age=()
  local -a smoke_intensity=()
  local -a sparks_x=()
  local -a sparks_y=()
  local -a sparks_age=()
  local -a rocket_flames_x=()
  local -a rocket_flames_y=()
  local -a rocket_flames_age=()
  
  # Rocket ascent variables
  local rocket_ascent_start=$((cols / 3))
  local rocket_ascending=0
  local rocket_altitude=0
  
  # Clear screen and prepare for animation
  clear
  
  # Create a buffer for the entire screen
  local screen_buffer=""
  
  # Main animation loop
  for ((pos=start_pos; (reverse == 1 && pos > end_pos) || (reverse == 0 && pos < end_pos); pos+=step)); do
    screen_buffer=""
    
    # Handle rocket ascent
    if [[ $train_type == "rocket" && $pos -gt $rocket_ascent_start && $rocket_ascending -eq 0 ]]; then
      rocket_ascending=1
    fi
    
    if [[ $rocket_ascending -eq 1 ]]; then
      rocket_altitude=$((rocket_altitude + 1))
      ground_level=$((ground_level - 1))
      
      # Add rocket flames
      if ((RANDOM % 2 == 0)); then
        rocket_flames_x+=($((pos + train_width/2)))
        rocket_flames_y+=($((ground_level + ${#train_frames[@]} + 1)))
        rocket_flames_age+=(0)
      fi
    fi
    
    # Draw ground
    if [[ $colors -eq 1 && $ground_level -lt $((rows - 1)) ]]; then
      screen_buffer+="\033[${ground_level};0H${ground_color}"
      for ((i=0;i<cols;i++)); do screen_buffer+="="; done
      screen_buffer+="${NC}"
    fi
    
    # Smoke trail effect with fading
    if [[ $smoke_trail -eq 1 && ($train_type == "steam" || $train_type == "rocket") ]]; then
      # Add new smoke particles
      if ((RANDOM % 3 == 0)); then
        smoke_x+=($((pos + 10))) 
        if [[ $train_type == "rocket" ]]; then
          smoke_y+=($((ground_level + ${#train_frames[@]} - 2)))
        else
          smoke_y+=($((ground_level - 8)))
        fi
        smoke_age+=(0)
        smoke_intensity+=(7)  # Start with bright white
      fi
      
      # Update and draw smoke particles with fading
      for ((s=0; s<${#smoke_x[@]}; s++)); do
        [[ -n "${smoke_x[s]}" ]] || continue
        smoke_age[s]=$((smoke_age[s] + 1))
        smoke_y[s]=$((smoke_y[s] - 1 - (RANDOM % 2)))
        smoke_x[s]=$((smoke_x[s] + (RANDOM % 3 - 1)))
        
        # Fade smoke intensity
        if [[ ${smoke_age[s]} -gt 5 && ${smoke_intensity[s]} -gt 0 ]]; then
          smoke_intensity[s]=$((smoke_intensity[s] - 1))
        fi
        
        if [[ ${smoke_age[s]} -lt 20 && ${smoke_y[s]} -gt 0 && ${smoke_x[s]} -gt 0 && ${smoke_x[s]} -lt $cols ]]; then
          screen_buffer+="\033[${smoke_y[s]};${smoke_x[s]}H\033[${smoke_intensity[s]}m·${NC}"
        fi
      done
      
      # Clean up old smoke particles
      for ((s=${#smoke_x[@]}-1; s>=0; s--)); do
        [[ ${smoke_age[s]} -ge 20 ]] && unset smoke_x[s] && unset smoke_y[s] && unset smoke_age[s] && unset smoke_intensity[s]
      done
      smoke_x=("${smoke_x[@]}")
      smoke_y=("${smoke_y[@]}")
      smoke_age=("${smoke_age[@]}")
      smoke_intensity=("${smoke_intensity[@]}")
    fi
    
    # Rocket flames effect
    if [[ $train_type == "rocket" ]]; then
      for ((f=0; f<${#rocket_flames_x[@]}; f++)); do
        [[ -n "${rocket_flames_x[f]}" ]] || continue
        rocket_flames_age[f]=$((rocket_flames_age[f] + 1))
        rocket_flames_y[f]=$((rocket_flames_y[f] + 1))
        
        if [[ ${rocket_flames_age[f]} -lt 6 && ${rocket_flames_y[f]} -lt $rows ]]; then
          local flame_chars=("|" "!" "|" "!")
          screen_buffer+="\033[${rocket_flames_y[f]};${rocket_flames_x[f]}H${rocket_flame_color}${flame_chars[$RANDOM % 4]}${NC}"
        fi
      done
      
      for ((f=${#rocket_flames_x[@]}-1; f>=0; f--)); do
        [[ ${rocket_flames_age[f]} -ge 6 ]] && unset rocket_flames_x[f] && unset rocket_flames_y[f] && unset rocket_flames_age[f]
      done
      rocket_flames_x=("${rocket_flames_x[@]}")
      rocket_flames_y=("${rocket_flames_y[@]}")
      rocket_flames_age=("${rocket_flames_age[@]}")
    fi
    
    # Sparks effect for steam train
    if [[ $train_type == "steam" && $((RANDOM % 5)) == 0 ]]; then
      sparks_x+=($((pos + 15)))
      sparks_y+=($((ground_level - 1)))
      sparks_age+=(0)
    fi
    
    for ((sp=0; sp<${#sparks_x[@]}; sp++)); do
      [[ -n "${sparks_x[sp]}" ]] || continue
      sparks_age[sp]=$((sparks_age[sp] + 1))
      sparks_y[sp]=$((sparks_y[sp] + 1))
      sparks_x[sp]=$((sparks_x[sp] + (RANDOM % 3 - 1)))
      
      if [[ ${sparks_age[sp]} -lt 8 && ${sparks_y[sp]} -lt $((ground_level + 2)) && ${sparks_x[sp]} -gt 0 && ${sparks_x[sp]} -lt $cols ]]; then
        screen_buffer+="\033[${sparks_y[sp]};${sparks_x[sp]}H${spark_color}*${NC}"
      fi
    done
    
    for ((sp=${#sparks_x[@]}-1; sp>=0; sp--)); do
      [[ ${sparks_age[sp]} -ge 8 ]] && unset sparks_x[sp] && unset sparks_y[sp] && unset sparks_age[sp]
    done
    sparks_x=("${sparks_x[@]}")
    sparks_y=("${sparks_y[@]}")
    sparks_age=("${sparks_age[@]}")
    
    # Draw train
    local line_num=0
    for line in "${train_frames[@]}"; do
      if [[ $pos -gt -${#line} && $pos -lt $cols ]]; then
        local draw_y=$((ground_level - ${#train_frames[@]} + line_num))
        if [[ $draw_y -gt 0 && $draw_y -le $rows ]]; then
          screen_buffer+="\033[${draw_y};${pos}H${train_color}${line}${NC}"
        fi
      fi
      ((line_num++))
    done
    
    # Special behaviors for different train types
    case $train_type in
      "bullet")
        # Bullet train leaves a speed trail
        if ((RANDOM % 3 == 0)); then
          for ((i=1; i<=3; i++)); do
            local trail_x=$((pos - i * 5))
            if [[ $trail_x -gt 0 && $trail_x -lt $cols ]]; then
              screen_buffer+="\033[${ground_level};${trail_x}H${CYAN}-${NC}"
            fi
          done
        fi
        ;;
      "metro")
        # Metro train has blinking lights
        if (( (pos / 2) % 4 == 0 )); then
          local light_y=$((ground_level - ${#train_frames[@]} + 2))
          local light_x=$((pos + 5))
          screen_buffer+="\033[${light_y};${light_x}H${YELLOW}*${NC}"
        fi
        ;;
      "tram")
        # Tram has bell sound indicator
        if ((pos % 20 == 0)); then
          screen_buffer+="\033[$((ground_level - ${#train_frames[@]} - 1));$((pos + 8))H${MAGENTA}🔔${NC}"
        fi
        ;;
    esac
    
    # Flying effect
    if [[ $fly -eq 1 ]]; then
      screen_buffer+="\033[$((ground_level - ${#train_frames[@]} - 2));$((pos + 10))H${spark_color}~~~~FLYING TRAIN~~~~${NC}"
    fi
    
    # Accident effect
    if [[ $accident -eq 1 && $pos -gt $((cols/2)) ]]; then
      screen_buffer+="\033[1;1H${train_color}CRASH! DERAILMENT!${NC}"
    fi
    
    # Display the entire frame at once
    echo -ne "$screen_buffer"
    
    # Adjust speed based on train type
    case $train_type in
      "bullet") sleep 0.02 ;;
      "rocket") sleep 0.015 ;;
      "metro") sleep 0.04 ;;
      "tram") sleep 0.06 ;;
      "freight") sleep 0.08 ;;
      *) sleep 0.03 ;;
    esac
  done
  
  # Clean up
  tput cnorm
  stty echo
  clear
  
  # Display appropriate message based on train type
  case $train_type in
    "rocket") 
      echo -e "${spark_color}"
      echo "    🚀"
      echo "   /|\\"
      echo "  / | \\"
      echo " /  |  \\"
      echo -e "Rocket train has left for space!${NC}"
      ;;
    "bullet") 
      echo -e "${train_color}💨 Bullet train arrived in record time!${NC}"
      ;;
    "freight") 
      echo -e "${ground_color}"
      echo "  📦📦📦"
      echo "  |_____|"
      echo -e "Freight delivered successfully!${NC}"
      ;;
    "metro")
      echo -e "${BLUE}🚇 Metro train has reached its destination!${NC}"
      ;;
    "tram")
      echo -e "${MAGENTA}🚋 Tram service completed!${NC}"
      ;;
    *) 
      echo -e "${train_color}"
      echo -e "    ____"
      echo -e "   / [] \\"
      echo -e "  |      |"
      echo -e "  |______|"
      echo -e "All aboard the Bahoot express!${NC}"
      ;;
  esac
}

# 🧠 Diagnostic scanner with CPU/Mem info
doctor() {
  echo -e "${GREEN}🔍 Running diagnostics...${NC}"
  sleep 0.5
  echo "✅ Bash version: $(bash --version | head -n 1)"
  echo "✅ Terminal: $TERM"
  echo "✅ User: $USER"
  echo "✅ Host: $(hostname)"
  UPTIME=$(uptime -p 2>/dev/null || uptime)
  echo "✅ Uptime: $UPTIME"
  
  # CPU info
  if command -v lscpu >/dev/null 2>&1; then
    echo "✅ CPU: $(lscpu | grep 'Model name' | cut -d':' -f2 | xargs)"
  elif command -v sysctl >/dev/null 2>&1; then
    echo "✅ CPU: $(sysctl -n machdep.cpu.brand_string 2>/dev/null || echo "Unknown")"
  fi
  
  # Memory info
  if command -v free >/dev/null 2>&1; then
    echo "✅ Memory: $(free -h | grep Mem | awk '{print $3 "/" $2}') used"
  elif command -v vm_stat >/dev/null 2>&1; then
    memory=$(vm_stat | grep "Pages active" | awk '{print $3}' | tr -d '.' 2>/dev/null || echo "256")
    echo "✅ Memory: ~$((memory / 256))MB active"
  fi
}

# 💥 Fake meltdown with randomized errors
prank() {
  (loader) &
  loader_pid=$!
  sleep 2
  kill $loader_pid 2>/dev/null
  echo -e "\b \n"
  
  errors=(
    "KERNEL_SECURITY_CHECK_FAILURE"
    "CRITICAL_PROCESS_DIED" 
    "SYSTEM_THREAD_EXCEPTION_NOT_HANDLED"
    "IRQL_NOT_LESS_OR_EQUAL"
    "PAGE_FAULT_IN_NONPAGED_AREA"
    "DRIVER_IRQL_NOT_LESS_OR_EQUAL"
    "KMODE_EXCEPTION_NOT_HANDLED"
  )
  
  for i in {1..5}; do
    echo -e "${RED}💥 SYSTEM FAILURE DETECTED${NC}"
    sleep 0.2
    echo -e "${YELLOW} Dumping memory...${NC}"
    sleep 0.3
    echo -e "${RED} ${errors[$RANDOM % ${#errors[@]}]}${NC}"
    sleep 0.3
    clear
  done
  echo -e "${RED} Memory dumped.${NC}"
  sleep 1
  echo -e "${GREEN}Just kidding 😎${NC}"
}

# 🧨 Chaos mode with screen flashes - FIXED DIVISION BY ZERO
chaos() {
  echo -e "${CYAN}🧨 Entering chaos mode...${NC}"
  sleep 0.5
  
  # Define errors array to avoid division by zero
  errors=(
    "KERNEL_SECURITY_CHECK_FAILURE"
    "CRITICAL_PROCESS_DIED" 
    "SYSTEM_THREAD_EXCEPTION_NOT_HANDLED"
    "IRQL_NOT_LESS_OR_EQUAL"
    "PAGE_FAULT_IN_NONPAGED_AREA"
    "DRIVER_IRQL_NOT_LESS_OR_EQUAL"
    "KMODE_EXCEPTION_NOT_HANDLED"
    "SANITY_NOT_FOUND"
    "BAHOOT_OVERFLOW"
    "TERMINAL_TOO_COOL"
  )
  errors_count=${#errors[@]}
  
  for i in {1..30}; do
    color=$((31 + (i % 6)))
    echo -e "\033[1;${color}mERROR $i: ${errors[$((RANDOM % errors_count))]}${NC}"
    
    # Random screen flash
    if ((RANDOM % 5 == 0)); then
      tput bel
      clear
      sleep 0.1
    fi
    
    sleep 0.07
  done
  
  for i in {1..10}; do
    echo -e "\033[1;33mCHAOS LEVEL: $((RANDOM % 100))%${NC}"
    sleep 0.05
  done
  echo -e "${CYAN}💫 Chaos complete.${NC}"
}

# 🧪 Matrix mode with pre-generated charset
matrix() {
  echo -e "${GREEN}🧪 Entering matrix mode...${NC}"
  cols=$(tput cols)
  rows=$(tput lines)
  
  # Pre-generate character set
  chars=()
  for c in {a..z} {A..Z} {0..9}; do
    chars+=("$c")
  done
  chars_len=${#chars[@]}
  
  trap "tput cnorm; clear; exit" SIGINT SIGTERM
  tput civis
  clear
  
  # Each stream has a position and length
  local -a pos
  local -a len
  for ((i=0; i<cols; i++)); do
    pos[i]=$((RANDOM % rows))
    len[i]=$((3 + RANDOM % (rows/2)))
  done
  
  for ((frame=0; frame<200; frame++)); do
    for ((i=0; i<cols; i++)); do
      # Print fading trail
      for ((j=0; j<len[i]; j++)); do
        y=$((pos[i] - j))
        if ((y > 0 && y <= rows)); then
          char_idx=$((RANDOM % chars_len))
          if ((j == 0)); then
            printf "\033[%d;%dH\033[1;97m%s\033[0m" "$y" "$((i+1))" "${chars[char_idx]}"
          elif ((j < len[i]/2)); then
            printf "\033[%d;%dH\033[1;32m%s\033[0m" "$y" "$((i+1))" "${chars[char_idx]}"
          else
            printf "\033[%d;%dH\033[0;32m%s\033[0m" "$y" "$((i+1))" "${chars[char_idx]}"
          fi
        fi
      done
      # Move stream down
      pos[i]=$((pos[i]+1))
      if ((pos[i] - len[i] > rows)); then
        pos[i]=1
        len[i]=$((3 + RANDOM % (rows/2)))
      fi
    done
    sleep 0.05
  done
  tput cnorm
  echo -e "${GREEN}\n🧠 Matrix exited.${NC}"
}

# Banner with pulse effect after typing
banner() {
  local lines=(
" ______  _______ _     _  _____   _____  _______"
" |_____] |_____| |_____| |     | |     |    |   "
" |_____] |     | |     | |_____| |_____|    |   "
  )
  clear
  for line in "${lines[@]}"; do
    # print each character with a short delay for a typewriter effect
    for ((i=0; i<${#line}; i++)); do
      echo -ne "${CYAN}${line:$i:1}${NC}"
      sleep 0.01
    done
    echo ""  # new line after each banner line
    sleep 0.15
  done
  
  # Pulse effect
  for i in {1..3}; do
    for color in "${CYAN}" "${BLUE}" "${MAGENTA}" "${CYAN}"; do
      printf "\033[3A"  # Move up 3 lines
      for line in "${lines[@]}"; do
        echo -ne "${color}${line}${NC}"
        echo
      done
      sleep 0.2
    done
  done
}
# 🔄 Self-update with checksum verification - SILENT VERSION
update() {
  local backup_file="$0.bak"
  cp "$0" "$backup_file" &>/dev/null

  # old checksum
  local old_checksum=""
  if command -v md5sum &>/dev/null; then
    old_checksum=$(md5sum "$0" 2>/dev/null | cut -d' ' -f1)
  elif command -v md5 &>/dev/null; then
    old_checksum=$(md5 -q "$0" 2>/dev/null)
  fi

  # download update silently
  if curl -fsSL https://raw.githubusercontent.com/superskibidi69/funny-cli/main/bahoot -o "$0.tmp" &>/dev/null; then
    local new_checksum=""
    if command -v md5sum &>/dev/null; then
      new_checksum=$(md5sum "$0.tmp" 2>/dev/null | cut -d' ' -f1)
    elif command -v md5 &>/dev/null; then
      new_checksum=$(md5 -q "$0.tmp" 2>/dev/null)
    fi

    if [[ -n "$new_checksum" && "$old_checksum" != "$new_checksum" ]]; then
      chmod +x "$0.tmp" &>/dev/null
      mv "$0.tmp" "$0" &>/dev/null
      echo -e "${GREEN}✅ Update complete!${NC}"
    else
      rm -f "$0.tmp" &>/dev/null
    fi
    rm -f "$backup_file" &>/dev/null
  else
    echo -e "${RED}❌ Update failed.${NC}"
    rm -f "$backup_file" &>/dev/null
  fi
}


# 💣 uninstall with countdown
uninstall() {
  echo -e "${RED}💣 Uninstall sequence initiated...${NC}"
  for i in {5..1}; do
    echo -e "${RED}$i...${NC}"
    sleep 1
  done
  echo "Deleting Bahoot CLI from: $0"
  rm -- "$0"
  echo -e "${RED}💥 BOOM!${NC}"
}
# 🎭 Troll mode with real IP detection from system and fallback to ifconfig.me
troll() {
  echo -e "${RED}🔍 Initializing system scan...${NC}"
  sleep 1
  
  # Show loader while "fetching" data
# Show loader while "fetching" data
(loader) &
loader_pid=$!
sleep 2
kill $loader_pid 2>/dev/null
wait $loader_pid 2>/dev/null || true   # ✅ reap quietly, no hang
echo -e "\b \n"
  # Try to get real IP using multiple methods
  local ip=""
  local city=""
  local country=""
  local isp=""
  
  # Method 1: Try system commands first (most reliable)
  if command -v ip >/dev/null 2>&1; then
    # Linux systems with ip command
    ip=$(ip route get 1 2>/dev/null | awk '{for(i=1;i<=NF;i++) if ($i=="src") print $(i+1)}' | head -1)
  elif command -v ifconfig >/dev/null 2>&1; then
    # macOS/Linux with ifconfig
    ip=$(ifconfig 2>/dev/null | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | head -1)
  fi
  
  # If we got a local IP, try to get public IP from external services
  if [[ -n "$ip" && "$ip" =~ ^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.) ]]; then
    # It's a private IP, need to get public IP from external service
    ip=""
  fi
  
  # Method 2: Try external services for public IP
  if [[ -z "$ip" ]]; then
    # Try multiple public IP services with timeout
    if command -v curl >/dev/null 2>&1; then
      # Try ifconfig.me first (simple and fast)
      ip=$(curl -s --connect-timeout 3 "https://ifconfig.me/ip" 2>/dev/null || echo "")
      
      # If that fails, try ipinfo.io
      if [[ -z "$ip" ]]; then
        ip_data=$(curl -s --connect-timeout 3 "https://ipinfo.io/json" 2>/dev/null || echo "")
        if [[ -n "$ip_data" ]]; then
          ip=$(echo "$ip_data" | grep -o '"ip":"[^"]*' | head -1 | cut -d'"' -f4)
          city=$(echo "$ip_data" | grep -o '"city":"[^"]*' | head -1 | cut -d'"' -f4)
          country=$(echo "$ip_data" | grep -o '"country":"[^"]*' | head -1 | cut -d'"' -f4)
          isp=$(echo "$ip_data" | grep -o '"org":"[^"]*' | head -1 | cut -d'"' -f4)
        fi
      fi
      
      # If we have IP but no other info, try to get location info
      if [[ -n "$ip" && -z "$city" ]]; then
        location_data=$(curl -s --connect-timeout 3 "https://ipapi.co/${ip}/json/" 2>/dev/null || echo "")
        if [[ -n "$location_data" ]]; then
          city=$(echo "$location_data" | grep -o '"city":"[^"]*' | head -1 | cut -d'"' -f4)
          country=$(echo "$location_data" | grep -o '"country_name":"[^"]*' | head -1 | cut -d'"' -f4)
          isp=$(echo "$location_data" | grep -o '"org":"[^"]*' | head -1 | cut -d'"' -f4)
        fi
      fi
    fi
  fi
  
  messages=(
    "Scanning network interfaces..."
    "Analyzing system vulnerabilities..."
    "Bypassing firewall protections..."
    "Establishing secure connection to Bahoot HQ..."
    "Downloading exploit toolkit..."
    "Injecting payload into system memory..."
  )
  
  for msg in "${messages[@]}"; do
    echo -e "${YELLOW}$msg${NC}"
    sleep $(awk "BEGIN {print 0.3 + 0.4 * $RANDOM / 32767}")
  done
  
  echo -e "${GREEN}✅ Security scan complete!${NC}"
  echo
  
  # Display IP information (real or fake)
  if [[ -n "$ip" ]]; then
    echo -e "${CYAN}📡 Network Information:${NC}"
    echo -e "IP Address: ${GREEN}$ip${NC}"
    
    # Show additional network info if available
    if command -v ip >/dev/null 2>&1; then
      local interface_count=$(ip link show 2>/dev/null | grep -c "^[0-9]" || echo "0")
      echo -e "Network Interfaces: ${GREEN}$interface_count detected${NC}"
    fi
  else
    use_fallback_data
  fi
  
  echo
  sleep 1
  
  # More "hacking" messages
  echo -e "${RED}🚨 CRITICAL FINDINGS:${NC}"
  critical_messages=(
    "Multiple open ports detected"
    "Outdated security protocols"
    "Unencrypted data transmission"
    "Vulnerable to Bahoot injection"
    "Firewall rules need updating"
    "Suspicious activity detected"
    "Weak password policies found"
    "Unpatched system vulnerabilities"
  )
  
  # Show 3-5 random critical findings
  local num_findings=$((3 + RANDOM % 3))
  for ((i=0; i<num_findings; i++)); do
    echo -e "⚠️  ${critical_messages[$RANDOM % ${#critical_messages[@]}]}"
    sleep 0.5
  done
  
  echo
  sleep 1
  
  # Final "threat" messages with more drama
  final_messages=(
    "Sending your browsing history to Bahoot HQ... 📡"
    "Installing harmless surveillance cookie... 🍪"
    "Adding your computer to Bahoot botnet... 🤖"
    "Downloading your meme collection... 📂"
    "Backing up your embarrassing photos... 📸"
    "Syncing your search history with the cloud... ☁️"
    "Analyzing your typing patterns... ⌨️"
    "Cataloging your favorite websites... 🌐"
  )
  
  # Show 4-6 random final messages
  local num_final=$((4 + RANDOM % 3))
  for ((i=0; i<num_final; i++)); do
    local msg="${final_messages[$RANDOM % ${#final_messages[@]}]}"
    echo -e "${MAGENTA}$msg${NC}"
    sleep $(awk "BEGIN {print 0.4 + 0.3 * $RANDOM / 32767}")
  done
  
  echo
  sleep 1
  echo -e "${GREEN}🏴‍☠️ Just kidding! Your system is safe... probably 😈${NC}"
  echo -e "${YELLOW}This was all simulated - no actual data was sent anywhere!${NC}"
  
  # Add context about the IP info shown
  if [[ -n "$ip" ]]; then
    echo -e "${BLUE}   This is public information available to any website you visit${NC}"
  else
    echo -e "${BLUE}💡 Could not retrieve real IP data - showing simulated information${NC}"
  fi
}

# Helper function for fallback data
use_fallback_data() {
  local fake_ips=("192.168.1." "10.0.0." "172.16.0." "203.0.113.")
  local fake_cities=("New York" "London" "Tokyo" "Berlin" "Paris" "Sydney" "Toronto" "Singapore")
  local fake_countries=("United States" "United Kingdom" "Japan" "Germany" "France" "Australia" "Canada" "Singapore")
  local fake_isps=("Comcast" "Verizon" "AT&T" "Spectrum" "BT" "Deutsche Telekom" "Rogers" "Singtel")
  
  local ip="${fake_ips[$RANDOM % ${#fake_ips[@]}]}$((RANDOM % 255))"
  local city="${fake_cities[$RANDOM % ${#fake_cities[@]}]}"
  local country="${fake_countries[$RANDOM % ${#fake_countries[@]}]}"
  local isp="${fake_isps[$RANDOM % ${#fake_isps[@]}]}"
  
  echo -e "${CYAN}📡 Network Information:${NC}"
  echo -e "IP Address: ${GREEN}$ip${NC}"
  echo -e "Location: ${GREEN}$city, $country${NC}"
  echo -e "ISP: ${GREEN}$isp${NC}"
  echo -e "${YELLOW}Note: This is simulated data (real IP detection failed)${NC}"
}

# 🎉 Party mode with ASCII fireworks
party() {
  echo -e "${YELLOW}🎉 Welcome to Bahoot Party Mode!${NC}"
  
  fireworks=(
"          .     .\n         / \\   / \\\n    .---'     '     '---.\n   /                     \\\n  (      B A H O O T      )\n   \\                     /\n    ''--.         .--''\n         '-------'"
"    *       .\n      *   *\n   .    *    .\n      *   *\n    *       ."
"   \\ | /\n  - BAHOOT -\n   / | \\"
"   .-^-.\n  /     \\\n ( B A H )\n  \\     /\n   '-.-'"
  )
  
  for i in {1..5}; do
    clear
    color=$((31 + (RANDOM % 6)))
    echo -e "\033[1;${color}m${fireworks[$RANDOM % ${#fireworks[@]}]}${NC}"
    echo -e "\033[1;${color}m🎊 🎈 🎉 Bahoot rocks! 🎉 🎈 🎊${NC}"
    sleep 0.3
  done
  echo -e "${GREEN}🎵 Party's over, back to work!${NC}"
}

# 🏓 Pong game (first to 10 wins)
pong() {
  # Hide cursor and disable input echoing
  tput civis
  stty -echo
  
  # Game variables
  local cols=$(tput cols)
  local rows=$(tput lines)
  local score_left=0
  local score_right=0
  local paddle_height=6
  local left_paddle_y=$((rows/2 - paddle_height/2))
  local right_paddle_y=$((rows/2 - paddle_height/2))
  local ball_x=$((cols/2))
  local ball_y=$((rows/2))
  local ball_dx=1
  local ball_dy=1
  local winner=""
  local paddle_char="█"
  local ball_char="●"
  local prev_ball_x=$ball_x
  local prev_ball_y=$ball_y
  local quit_game=0
  local ball_speed=0.05  # Slightly slower ball speed
  
  # Colors
  local left_color="\033[1;36m"   # Cyan
  local right_color="\033[1;35m"  # Magenta
  local ball_color="\033[1;33m"   # Yellow
  local score_color="\033[1;32m"  # Green
  
  # Trap to restore terminal settings on exit
  trap "tput cnorm; stty echo; clear; exit" SIGINT SIGTERM
  
  # Draw the initial game state
  clear
  
  # Draw borders and initial score
  printf "\033[0;0H"
  printf "${score_color}Player: %-2d   CPU: %-2d${NC}\n" "$score_left" "$score_right"
  printf "═%.0s" $(seq 1 $cols)
  for ((y=3; y<rows-1; y++)); do
    printf "\033[%d;0H" "$y"
    printf " "
    printf "\033[%d;%dH" "$y" "$cols"
    printf " "
  done
  printf "\033[%d;0H" "$((rows-1))"
  printf "═%.0s" $(seq 1 $cols)
  printf "\033[%d;0H" "$rows"
  printf "Use ↑/↓ to move, Q to quit"
  
  # Draw initial paddles
  for ((i=0; i<paddle_height; i++)); do
    printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$((left_paddle_y + i))"
    printf "\033[%d;%dH${right_color}${paddle_char}${NC}" "$((right_paddle_y + i))" "$((cols-1))"
  done
  
  # Draw initial ball
  printf "\033[%d;%dH${ball_color}${ball_char}${NC}" "$ball_y" "$ball_x"
  
  # Game loop
  while [[ $score_left -lt 10 && $score_right -lt 10 && $quit_game -eq 0 ]]; do
    # Store previous ball position
    prev_ball_x=$ball_x
    prev_ball_y=$ball_y
    
    # Move ball
    ball_x=$((ball_x + ball_dx))
    ball_y=$((ball_y + ball_dy))
    
    # Ball collision with top/bottom - fix sticking at edges
    if [[ $ball_y -le 2 ]]; then
      ball_y=3
      ball_dy=1
    elif [[ $ball_y -ge $((rows-1)) ]]; then
      ball_y=$((rows-2))
      ball_dy=-1
    fi
    
    # Ball collision with left paddle - fix paddle "splitting"
    if [[ $ball_x -eq 1 && $ball_y -ge $left_paddle_y && $ball_y -lt $((left_paddle_y + paddle_height)) ]]; then
      ball_dx=1
      # Adjust angle based on where the ball hit the paddle
      local hit_pos=$((ball_y - left_paddle_y))
      if [[ $hit_pos -eq 0 || $hit_pos -eq 1 ]]; then
        ball_dy=-1
      elif [[ $hit_pos -eq $((paddle_height-1)) || $hit_pos -eq $((paddle_height-2)) ]]; then
        ball_dy=1
      else
        ball_dy=0  # Straight shot for middle hits
      fi
      # Ensure ball doesn't get stuck in paddle
      ball_x=2
    fi
    
    # Ball collision with right paddle (CPU) - fix paddle "splitting"
    if [[ $ball_x -eq $((cols-2)) && $ball_y -ge $right_paddle_y && $ball_y -lt $((right_paddle_y + paddle_height)) ]]; then
      ball_dx=-1
      # Adjust angle based on where the ball hit the paddle
      local hit_pos=$((ball_y - right_paddle_y))
      if [[ $hit_pos -eq 0 || $hit_pos -eq 1 ]]; then
        ball_dy=-1
      elif [[ $hit_pos -eq $((paddle_height-1)) || $hit_pos -eq $((paddle_height-2)) ]]; then
        ball_dy=1
      else
        ball_dy=0  # Straight shot for middle hits
      fi
      # Ensure ball doesn't get stuck in paddle
      ball_x=$((cols-3))
    fi
    
    # Score points
    if [[ $ball_x -le 0 ]]; then
      score_right=$((score_right + 1))
      # Update score display immediately
      printf "\033[0;15H${score_color}%-2d${NC}" "$score_right"
      ball_x=$((cols/2))
      ball_y=$((rows/2))
      ball_dx=1
      ball_dy=$((RANDOM % 3 - 1))  # Random initial angle
      # Clear old ball
      printf "\033[%d;%dH " "$prev_ball_y" "$prev_ball_x"
      # Draw new ball
      printf "\033[%d;%dH${ball_color}${ball_char}${NC}" "$ball_y" "$ball_x"
      # Redraw paddles to fix any visual issues
      for ((i=0; i<paddle_height; i++)); do
        printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$((left_paddle_y + i))"
        printf "\033[%d;%dH${right_color}${paddle_char}${NC}" "$((right_paddle_y + i))" "$((cols-1))"
      done
      sleep 0.5
      continue
    elif [[ $ball_x -ge $((cols-1)) ]]; then
      score_left=$((score_left + 1))
      # Update score display immediately
      printf "\033[0;8H${score_color}%-2d${NC}" "$score_left"
      ball_x=$((cols/2))
      ball_y=$((rows/2))
      ball_dx=-1
      ball_dy=$((RANDOM % 3 - 1))  # Random initial angle
      # Clear old ball
      printf "\033[%d;%dH " "$prev_ball_y" "$prev_ball_x"
      # Draw new ball
      printf "\033[%d;%dH${ball_color}${ball_char}${NC}" "$ball_y" "$ball_x"
      # Redraw paddles to fix any visual issues
      for ((i=0; i<paddle_height; i++)); do
        printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$((left_paddle_y + i))"
        printf "\033[%d;%dH${right_color}${paddle_char}${NC}" "$((right_paddle_y + i))" "$((cols-1))"
      done
      sleep 0.5
      continue
    fi
    
    # Improved CPU AI - better prediction and movement
    if [[ $ball_dx -gt 0 ]]; then  # Only move when ball is coming towards CPU
      # Predict where the ball will be
      local predicted_y=$ball_y
      local steps_to_reach=$(( (cols - 2 - ball_x) / ball_dx ))
      
      # Calculate bounce if needed
      if [[ $ball_dy -ne 0 ]]; then
        for ((i=0; i<steps_to_reach; i++)); do
          predicted_y=$((predicted_y + ball_dy))
          if [[ $predicted_y -le 2 ]]; then
            predicted_y=3
            ball_dy=1
          elif [[ $predicted_y -ge $((rows-1)) ]]; then
            predicted_y=$((rows-2))
            ball_dy=-1
          fi
        done
      fi
      
      # Move CPU paddle toward predicted position with some imperfection
      local target_y=$((predicted_y - paddle_height/2))
      
      # Add some randomness to make CPU beatable
      if (( RANDOM % 5 == 0 )); then  # 20% chance of error
        target_y=$((target_y + (RANDOM % 5 - 2)))
      fi
      
      # Keep target within bounds
      if [[ $target_y -lt 2 ]]; then
        target_y=2
      elif [[ $target_y -gt $((rows - paddle_height - 1)) ]]; then
        target_y=$((rows - paddle_height - 1))
      fi
      
      # Move CPU paddle
      if [[ $target_y -lt $right_paddle_y ]]; then
        # Move up
        if [[ $right_paddle_y -gt 2 ]]; then
          # Clear bottom of paddle
          printf "\033[%d;%dH " "$((right_paddle_y + paddle_height - 1))" "$((cols-1))"
          right_paddle_y=$((right_paddle_y - 1))
          # Draw top of paddle
          printf "\033[%d;%dH${right_color}${paddle_char}${NC}" "$right_paddle_y" "$((cols-1))"
        fi
      elif [[ $target_y -gt $right_paddle_y ]]; then
        # Move down
        if [[ $right_paddle_y -lt $((rows - paddle_height - 1)) ]]; then
          # Clear top of paddle
          printf "\033[%d;%dH " "$right_paddle_y" "$((cols-1))"
          right_paddle_y=$((right_paddle_y + 1))
          # Draw bottom of paddle
          printf "\033[%d;%dH${right_color}${paddle_char}${NC}" "$((right_paddle_y + paddle_height - 1))" "$((cols-1))"
        fi
      fi
    fi
    
    # Keep paddles in bounds
    if [[ $left_paddle_y -lt 2 ]]; then
      left_paddle_y=2
    elif [[ $left_paddle_y -gt $((rows - paddle_height - 1)) ]]; then
      left_paddle_y=$((rows - paddle_height - 1))
    fi
    
    if [[ $right_paddle_y -lt 2 ]]; then
      right_paddle_y=2
    elif [[ $right_paddle_y -gt $((rows - paddle_height - 1)) ]]; then
      right_paddle_y=$((rows - paddle_height - 1))
    fi
    
    # Read input with minimal delay for responsive controls
    local key=""
    while read -t 0.001 -n 1 -s key; do
      case "$key" in
        $'\033') 
          # Handle arrow keys
          read -t 0.001 -n 2 -s rest
          case "$rest" in
            "[A") # Up arrow
              if [[ $left_paddle_y -gt 2 ]]; then
                # Clear bottom of paddle
                printf "\033[%d;0H " "$((left_paddle_y + paddle_height - 1))"
                left_paddle_y=$((left_paddle_y - 1))
                # Draw top of paddle
                printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$left_paddle_y"
              fi
              ;;
            "[B") # Down arrow
              if [[ $left_paddle_y -lt $((rows - paddle_height - 1)) ]]; then
                # Clear top of paddle
                printf "\033[%d;0H " "$left_paddle_y"
                left_paddle_y=$((left_paddle_y + 1))
                # Draw bottom of paddle
                printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$((left_paddle_y + paddle_height - 1))"
              fi
              ;;
          esac
          ;;
        w|W) 
          # Move left paddle up
          if [[ $left_paddle_y -gt 2 ]]; then
            # Clear bottom of paddle
            printf "\033[%d;0H " "$((left_paddle_y + paddle_height - 1))"
            left_paddle_y=$((left_paddle_y - 1))
            # Draw top of paddle
            printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$left_paddle_y"
          fi
          ;;
        s|S) 
          # Move left paddle down
          if [[ $left_paddle_y -lt $((rows - paddle_height - 1)) ]]; then
            # Clear top of paddle
            printf "\033[%d;0H " "$left_paddle_y"
            left_paddle_y=$((left_paddle_y + 1))
            # Draw bottom of paddle
            printf "\033[%d;0H${left_color}${paddle_char}${NC}" "$((left_paddle_y + paddle_height - 1))"
          fi
          ;;
        q|Q) 
          quit_game=1
          break 2  # Break out of both loops
          ;;
      esac
    done
    
    # Only redraw ball if it moved
    if [[ $prev_ball_x -ne $ball_x || $prev_ball_y -ne $ball_y ]]; then
      # Clear old ball position
      printf "\033[%d;%dH " "$prev_ball_y" "$prev_ball_x"
      # Draw new ball position
      printf "\033[%d;%dH${ball_color}${ball_char}${NC}" "$ball_y" "$ball_x"
    fi
    
    # Small delay to make game playable (slightly slower ball)
    sleep $ball_speed
  done
  
  # Clear the game screen first
  clear
  
  # Display final results BEFORE restoring terminal settings
  if [[ $quit_game -eq 1 ]]; then
    echo -e "${score_color}Game quit${NC}"
    echo -e "Final score: ${score_color}Player: $score_left   CPU: $score_right${NC}"
  elif [[ $score_left -eq 10 ]]; then
    echo -e "${score_color}🏆 Player wins! 🏆${NC}"
    echo -e "Final score: ${score_color}Player: $score_left   CPU: $score_right${NC}"
  elif [[ $score_right -eq 10 ]]; then
    echo -e "${score_color}🏆 CPU wins! 🏆${NC}"
    echo -e "Final score: ${score_color}Player: $score_left   CPU: $score_right${NC}"
  fi
  
  # Restore terminal settings
  tput cnorm
  stty echo
  
  # Wait for a key press before returning
  echo
  read -n 1 -s -p "Press any key to continue..."
}

# 🦠 Fake virus scan with progress bar
scan() {
  echo -e "${RED}🦠 Scanning system for viruses...${NC}"
  
  # Progress bar animation
  for i in {1..20}; do
    percent=$((i * 5))
    bar=""
    for ((j=0; j<i; j++)); do bar+="█"; done
    for ((j=i; j<20; j++)); do bar+="░"; done
    echo -ne "\r[${bar}] ${percent}%"
    sleep 0.2
  done
  echo -e "\n"
  
  sleep 1
  echo "Found: 3 threats"
  sleep 1
  echo "Threat 1: Bahoot overload"
  echo "Threat 2: Excessive swag"
  echo "Threat 3: Terminal too cool"
  echo -e "${GREEN}✅ All threats neutralized.${NC}"
}

# 🖥️ Boot sequence with BIOS-style status
boot() {
  echo -e "${CYAN}🖥️ Booting Bahoot OS...${NC}"
  sleep 0.5
  
  boot_messages=(
    "Initializing kernel.............[ ${GREEN}OK${NC} ]"
    "Loading modules.................[ ${GREEN}OK${NC} ]"
    "Mounting /bahoot................[ ${GREEN}OK${NC} ]"
    "Checking system integrity.......[ ${GREEN}OK${NC} ]"
    "Starting services...............[ ${GREEN}OK${NC} ]"
    "Compiling C.....................[ ${GREEN}OK${NC} ]"
  )
  
  for msg in "${boot_messages[@]}"; do
    echo -e "$msg"
    sleep 0.5
  done
  
  echo "Welcome to Bahoot OS 🤖"
}

# 💻 Fake hacking with random IPs
hack() {
  echo -e "${GREEN}💻 Hacking in progress...${NC}"
  for i in {1..20}; do
    ip="$((RANDOM % 255)).$((RANDOM % 255)).$((RANDOM % 255)).$((RANDOM % 255))"
    echo "Accessing $ip... success"
    sleep 0.1
  done
  echo -e "${RED}🔥 Firewall breached. Just kidding.${NC}"
}
rocket() {
  tput civis
  trap "tput cnorm; stty echo; clear; exit" SIGINT SIGTERM

  local cols=$(tput cols)
  local rows=$(tput lines)
  local x=$((cols/2))
  local y=$((rows/2))
  local dx=1
  local dy=1
  local rocket="🧼"

  while true; do
    printf "\033[${y};${x}H "
    x=$((x + dx))
    y=$((y + dy))
    (( x <= 1 || x >= cols )) && dx=$(( -dx ))
    (( y <= 1 || y >= rows )) && dy=$(( -dy ))
    printf "\033[${y};${x}H\033[1;31m${rocket}\033[0m"
    sleep 0.03
  done
}

# ⚡ Glitch effect with color inversion
glitch() {
  chars="█▓▒░@#$%^&*()[]{}<>~ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
  cols=$(tput cols)
  for i in {1..15}; do
    clear
    for j in {1..8}; do
      len=$((10 + RANDOM % cols))
      str=""
      for ((k=0; k<len; k++)); do
        str+="${chars:RANDOM%${#chars}:1}"
      done
      color=$((31 + RANDOM % 7))
      
      # Random color inversion
      if ((RANDOM % 4 == 0)); then
        echo -e "\033[7;${color}m${str}${NC}"
      else
        echo -e "\033[1;${color}m${str}${NC}"
      fi
    done
    sleep 0.07
  done
  echo -e "${GREEN}System stabilized.${NC}"
}

# 🦑 Squid mode with water ripple effect
squid() {
  echo -e "${CYAN}🦑 Squid mode activated!${NC}"
  squid_frames=(
    "    ___\n   /   \\\n  | o o |\n   \\_-_/\n    |||\n   /|||\\\n  ( ||| )\n   \\|||/\n    vvv"
    "    ___\n   /   \\\n  | ^ ^ |\n   \\_-_/\n    |||\n   /|||\\\n  ( ||| )\n   \\|||/\n    ^^^  "
    "    ___\n   /   \\\n  | - - |\n   \\_u_/\n    |||\n   /|||\\\n  ( ||| )\n   \\|||/\n    ~~~"
    "    ___\n   /   \\\n  | o o |\n   \\_-_/\n    |||\n   \\|||/\n  ( ||| )\n   /|||\\\n    ^^^  "
  )
  
  ripple_frames=("~~~" "≈≈≈" "～～～" "∿∿∿")
  
  for cycle in {1..3}; do
    for frame in "${squid_frames[@]}"; do
      clear
      echo -e "${CYAN}$frame${NC}"
      echo -e "${BLUE}${ripple_frames[$RANDOM % ${#ripple_frames[@]}]}${NC}"
      echo -e "\n${GREEN}~ Swimming through the depths ~${NC}"
      sleep 0.4
    done
  done
  echo -e "${CYAN}🦑 Squid out!${NC}"
}

# 🦆 Duck spam with random pitch
duck() {
  echo -e "${YELLOW}Quack! Quack! Quack!${NC}"
  duck_frames=(
    "       __\n      (o >\n   \\_\\_\\)#_)\n~~~~~~~~~~~~~~~~~~~~~~~~"
    "       __\n      (o<\n   \\_\\_\\)#_)\n~~~~~~~~~~~~~~~~~~~~~~~~"
    "       __\n      (o >\n   \\_\\_\\)#_)  *splash*\n~~~~~~~~~~~~~~~~~~~~~~~~"
    "       __\n      (^ >\n   \\_\\_\\)#_)\n~~~~~~~~~~~~~~~~~~~~~~~~"
  )
  
  quacks=("QUACK!" "Quack!" "QUACK!!!" "quack..." "Quack?")
  
  positions=(5 10 15 20 25 30 20 15 10 5)
  
  for cycle in {1..2}; do
    for pos in "${positions[@]}"; do
      clear
      echo
      for ((i=0; i<pos; i++)); do echo -n " "; done
      echo -e "${YELLOW}${duck_frames[$((cycle % 4))]}${NC}"
      echo -e "\n${GREEN}${quacks[$RANDOM % ${#quacks[@]}]} Swimming around the pond!${NC}"
      sleep 0.3
    done
  done
  echo -e "${GREEN}All ducks have swum away.${NC}"
}

# 🦀 Crab rave with beat sync
crab() {
  echo -e "${CYAN}🦀 Crab rave started!${NC}"
  crab_frames=(
    "   \\o/  \\o/\n    |    |\n  _/ \\__/ \\_\n {.  \\_/  .}\n  \\._    _./\n     |  |\n    /    \\"
    "   \\o|  |o/\n    |    |\n  _/ \\__/ \\_\n {.  \\_/  .}\n  \\._    _./\n     |  |\n    /    \\"
    "   /o\\  /o\\\n    |    |\n  _/ \\__/ \\_\n {.  \\_/  .}\n  \\._    _./\n     |  |\n    /    \\"
    "   |o/  \\o|\n    |    |\n  _/ \\__/ \\_\n {.  \\_/  .}\n  \\._    _./\n     |  |\n    /    \\"
  )
  
  positions=(2 8 15 22 28 35 28 22 15 8 2)
  
  for cycle in {1..4}; do
    for pos in "${positions[@]}"; do
      clear
      echo
      for ((i=0; i<pos; i++)); do echo -n " "; done
      echo -e "${RED}${crab_frames[$((cycle % 4))]}${NC}"
      echo -e "\n${YELLOW}🎵 Crab rave! Moving sideways! 🎵${NC}"
      
      # Sync with beat - flash every 4 cycles
      if ((cycle % 4 == 0)); then
        sleep 0.2
        clear
        echo
        for ((i=0; i<pos; i++)); do echo -n " "; done
        echo -e "${YELLOW}${crab_frames[$((cycle % 4))]}${NC}"
        echo -e "\n${YELLOW}🎵 CRAB RAVE! 🎵${NC}"
      fi
      
      sleep 0.3
    done
  done
  echo -e "${GREEN}Crab rave ended.${NC}"
}

# 🐸 Frog rain from random positions
frog() {
  echo -e "${GREEN}🐸 Frog rain incoming...${NC}"
  cols=$(tput cols)
  for i in {1..20}; do
    x=$((RANDOM % cols + 1))
    printf "\033[2;%dH🐸" "$x"
    sleep 0.07
  done
  echo -e "\033[10;0H${CYAN}Frogs gone!${NC}"
}

# 🍀 Fortune with timestamp and color cycle
fortune() {
  quotes=("You will write bug-free code today." "Bahoot believes in you." "Your terminal is your canvas." "Don't forget to hydrate.")
  fortune_text="${quotes[$RANDOM % ${#quotes[@]}]}"
  
  # Color cycle
  colors=("$GREEN" "$CYAN" "$YELLOW" "$BLUE" "$MAGENTA")
  color="${colors[$RANDOM % ${#colors[@]}]}"
  
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  echo -e "${color}🍀 Fortune [${timestamp}]:${NC} $fortune_text"
}

# 🔊 Echo with flair and uppercase
echo_cmd() {
  echo -e "${CYAN}🔊 YOU SAID:${NC} ${*^^}"
}

# 🧼 Clear screen with fade effect
clear_cmd() {
  rows=$(tput lines)
  cols=$(tput cols)
  
  # Fill screen with spaces to create fade effect
  for ((i=0; i<rows; i++)); do
    line=""
    for ((j=0; j<cols; j++)); do
      line+=" "
    done
    echo "$line"
    sleep 0.02
  done
  
  clear
  echo -e "${GREEN}🧼 Screen cleared.${NC}"
}

# 📜 Credits with scrolling effect
credits() {
  credits_text=(
    "BAHOOT CLI CREDITS"
    "=================="
    ""
    "Created by: superfood"
    "Inspired by: chaos and shell magic"
    ""
    "Special thanks to:"
    "• The terminal enthusiasts"
    "• The open source community"
    "• Everyone who loves fun CLI tools"
    ""
    "Remember: Your terminal is your canvas!"
    ""
    "THE END"
  )
  
  rows=$(tput lines)
  clear
  
  for ((i=0; i<${#credits_text[@]}+rows; i++)); do
    clear
    for ((j=0; j<rows; j++)); do
      line_idx=$((i - j))
      if (( line_idx >= 0 && line_idx < ${#credits_text[@]} )); then
        # Center text
        text="${credits_text[line_idx]}"
        cols=$(tput cols)
        padding=$(( (cols - ${#text}) / 2 ))
        printf "%${padding}s" ""
        echo -e "${CYAN}${text}${NC}"
      else
        echo
      fi
    done
    sleep 0.2
  done
}
help_menu() {
  echo -e "${GREEN}Bahoot CLI 🤖 — Available commands:${NC}"
  printf "%-16s %s\n" "  ball" "Bouncing ball with color trail"
  printf "%-16s %s\n" "  banner" "Animated Bahoot ASCII logo"
  printf "%-16s %s\n" "  boot" "Simulate Bahoot OS boot sequence"
  printf "%-16s %s\n" "  chaos" "Print colorful chaos errors"
  printf "%-16s %s\n" "  crab" "Crab rave animation"
  printf "%-16s %s\n" "  credits" "Show Bahoot CLI credits"
  printf "%-16s %s\n" "  clear" "Clear the screen"
  printf "%-16s %s\n" "  clean" "Slowly clean the terminal"
  printf "%-16s %s\n" "  doctor" "Show system diagnostics"
  printf "%-16s %s\n" "  duck" "Spam the terminal with ducks"
  printf "%-16s %s\n" "  echo [text]" "Repeat your input with flair"
  printf "%-16s %s\n" "  fortune" "Get a random fortune/quote"
  printf "%-16s %s\n" "  frog" "Frog rain animation"
  printf "%-16s %s\n" "  glitch" "Terminal glitch effect"
  printf "%-16s %s\n" "  hack" "Fake hacking animation"
  printf "%-16s %s\n" "  help" "Show this help menu"
  printf "%-16s %s\n" "  matrix" "Matrix movie rain effect"
  printf "%-16s %s\n" "  party" "Celebrate with confetti"
  printf "%-16s %s\n" "  prank" "Fake system meltdown"
  printf "%-16s %s\n" "  scan" "Fake virus scan"
  printf "%-16s %s\n" "  uninstall" "Dramatically delete Bahoot CLI"
  printf "%-16s %s\n" "  squid" "Squid mode animation"
  printf "%-16s %s\n" "  pong" "Play Pong (first to 10 wins)"
  printf "%-16s %s\n" "  troll" "Print fake errors and warnings"
  printf "%-16s %s\n" "  update" "Update Bahoot CLI from GitHub"
  printf "%-16s %s\n" "  sl" "Steam locomotive animation. Options: -freight, -tram, -metro, -rocket, -bullet, -a, -F, -r"
}

ball() {
  tput civis  # hide cursor
  stty -echo  # disable input echoing
  
  local cols=$(tput cols)
  local rows=$(tput lines)
  local x=$((cols / 2))
  local y=$((rows / 2))
  local dx=1
  local dy=1
  local ball="●"
  local trail_char="·"
  local colors=(31 32 33 36 35 34)  # ANSI color codes: red, green, yellow, cyan, magenta, blue
  local color_index=0
  local trail_length=12  # Increased length for better visual effect
  
  # Arrays to store trail positions and colors
  local -a trail_x=()
  local -a trail_y=()
  local -a trail_c=()
  local -a trail_age=()  # Track age of each trail segment
  
  # Clear screen initially
  clear

  trap "tput cnorm; stty echo; clear; exit" SIGINT SIGTERM

  while true; do
    # Store current position for trail (with age 0)
    trail_x=("$x" "${trail_x[@]:0:$trail_length}")
    trail_y=("$y" "${trail_y[@]:0:$trail_length}")
    trail_c=("$color_index" "${trail_c[@]:0:$trail_length}")
    trail_age=(0 "${trail_age[@]:0:$trail_length}")  # Newest trail has age 0

    # Clear previous ball position
    printf "\033[%d;%dH " "$y" "$x"

    # Draw trail with fading effect based on age
    for ((t=0; t<${#trail_x[@]}; t++)); do
      if [[ -n "${trail_x[t]}" && -n "${trail_y[t]}" ]]; then
        # Increase age of this trail segment
        trail_age[t]=$((trail_age[t] + 1))
        
        # Remove trail segments that are too old
        if [[ ${trail_age[t]} -gt $((trail_length / 2)) ]]; then
          printf "\033[%d;%dH " "${trail_y[t]}" "${trail_x[t]}"
          # Mark for removal by setting to empty
          trail_x[t]=""
          trail_y[t]=""
        else
          # Calculate fade intensity based on age
          local fade_intensity=$((trail_age[t] * 2))
          if [[ $fade_intensity -gt 5 ]]; then
            fade_intensity=5  # Cap the fade intensity
          fi
          
          # Draw with appropriate fade
          printf "\033[%d;%dH\033[2;%dm%s\033[0m" "${trail_y[t]}" "${trail_x[t]}" "${colors[trail_c[t]]}" "$trail_char"
        fi
      fi
    done

    # Move ball
    ((x += dx))
    ((y += dy))

    # Bounce off edges with proper boundary checking
    if ((x <= 1)); then
      x=2
      dx=$(( -dx ))
      color_index=$(( (color_index + 1) % ${#colors[@]} ))
    elif ((x >= cols)); then
      x=$((cols - 1))
      dx=$(( -dx ))
      color_index=$(( (color_index + 1) % ${#colors[@]} ))
    fi

    if ((y <= 1)); then
      y=2
      dy=$(( -dy ))
      color_index=$(( (color_index + 1) % ${#colors[@]} ))
    elif ((y >= rows)); then
      y=$((rows - 1))
      dy=$(( -dy ))
      color_index=$(( (color_index + 1) % ${#colors[@]} ))
    fi

    # Draw ball with current color
    printf "\033[%d;%dH\033[1;%dm%s\033[0m" "$y" "$x" "${colors[$color_index]}" "$ball"

    # Refresh display
    printf "\033[0;0H"  # Move cursor to top-left to minimize flickering

    sleep 0.0635363
  done
}

case "$1" in
  prank) prank ;;
  clean) rocket ;;
  chaos) chaos ;;
  matrix) matrix ;;
  doctor) doctor ;;
  banner) banner ;;
  update) update ;;
  uninstall) uninstall ;;
  troll) troll ;;
  party) party ;;
  scan) scan ;;
  boot) boot ;;
  hack) hack ;;
  glitch) glitch ;;
  sl) shift; sl "$@" ;;
  ball) ball ;;
  squid) squid ;;
  duck) duck ;;
  crab) crab ;;
  frog) frog ;;
  fortune) fortune ;;
  pong) pong ;;
  echo) shift; echo_cmd "$@" ;;
  clear) clear_cmd ;;
  credits) credits ;;
  help|"") help_menu ;;
  *)
    echo "Error: command '$1' not found"
    exit 1
    ;;
esac